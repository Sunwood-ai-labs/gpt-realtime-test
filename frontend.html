<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Voice Agent — Realtime</title>
        <style>
            :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;font-size:16px}
            body{max-width:900px;margin:36px auto;padding:0 16px;color:#111}
            header h1{margin:.2rem 0}
            button{padding:.5rem .9rem;font-size:1rem}
            #status{margin-top:.5rem;color:#555}
            pre#log{background:#f7f7f8;border:1px solid #e1e1e6;padding:12px;height:220px;overflow:auto}
            audio{display:block;margin-top:12px}
        </style>
    </head>
    <body>
        <header>
            <h1>Voice Agent — Realtime demo</h1>
            <p>A small demo that creates a WebRTC session and plays remote audio from the realtime model. Click Start to request an ephemeral token and begin.</p>
        </header>

        <main>
            <button id="startBtn">Start realtime session</button>
            <button id="stopBtn" disabled>Stop</button>
            <div id="status" aria-live="polite">Idle</div>

            <h3>Log</h3>
            <pre id="log"></pre>

            <h3>Remote audio</h3>
            <audio id="remoteAudio" autoplay controls></audio>
        </main>

        <script>
            // Keep a minimal, well-documented startup flow and avoid top-level await.
            (function () {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const statusEl = document.getElementById('status');
                const logEl = document.getElementById('log');
                const audioEl = document.getElementById('remoteAudio');

                let pc = null;
                let localStream = null;
                let dc = null;

                function log(...args) {
                    const line = `[${new Date().toLocaleTimeString()}] ${args.join(' ')}\n`;
                    logEl.textContent += line;
                    logEl.scrollTop = logEl.scrollHeight;
                }

                function setStatus(text) {
                    statusEl.textContent = text;
                    log(text);
                }

                async function startSession() {
                    startBtn.disabled = true;
                    setStatus('Requesting ephemeral token...');

                    try {
                        const tokenResp = await fetch('/token');
                        if (!tokenResp.ok) throw new Error('Failed to fetch /token');
                        const tokenData = await tokenResp.json();
                        const EPHEMERAL_KEY = tokenData.value;

                        setStatus('Acquiring microphone...');
                        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                        setStatus('Creating RTCPeerConnection...');
                        pc = new RTCPeerConnection();

                        // Play remote audio when it arrives
                        pc.ontrack = (ev) => {
                            log('Received remote track');
                            audioEl.srcObject = ev.streams[0];
                        };

                        pc.onconnectionstatechange = () => {
                            log('Connection state: ' + pc.connectionState);
                        };

                        // Optional: handle remote data channel messages
                        pc.ondatachannel = (ev) => {
                            const ch = ev.channel;
                            ch.onmessage = (m) => log('Data channel message:', m.data);
                        };

                        // Add local audio track to the peer connection
                        const track = localStream.getAudioTracks()[0];
                        if (track) pc.addTrack(track, localStream);

                        // Create an outgoing data channel to receive events
                        dc = pc.createDataChannel('oai-events');
                        dc.onopen = () => log('Data channel opened');
                        dc.onmessage = (m) => log('Event:', m.data);

                        setStatus('Creating offer...');
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);

                        setStatus('Sending SDP to realtime backend...');
                        const baseUrl = 'https://api.openai.com/v1/realtime/calls';
                        const model = 'gpt-realtime';

                        const sdpResp = await fetch(`${baseUrl}?model=${encodeURIComponent(model)}`, {
                            method: 'POST',
                            body: offer.sdp,
                            headers: {
                                Authorization: `Bearer ${EPHEMERAL_KEY}`,
                                'Content-Type': 'application/sdp',
                            },
                        });

                        if (!sdpResp.ok) throw new Error('Realtime backend returned HTTP ' + sdpResp.status);

                        const answerSdp = await sdpResp.text();
                        await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

                        setStatus('Connected');
                        stopBtn.disabled = false;
                        log('Session started successfully');
                    } catch (err) {
                        log('Error:', err && err.message ? err.message : err);
                        setStatus('Error: ' + (err && err.message ? err.message : 'unknown'));
                        startBtn.disabled = false;
                    }
                }

                function stopSession() {
                    setStatus('Stopping session...');
                    if (pc) {
                        try { pc.close(); } catch (e) {}
                        pc = null;
                    }
                    if (localStream) {
                        localStream.getTracks().forEach(t => t.stop());
                        localStream = null;
                    }
                    stopBtn.disabled = true;
                    startBtn.disabled = false;
                    setStatus('Stopped');
                }

                startBtn.addEventListener('click', startSession);
                stopBtn.addEventListener('click', stopSession);
            })();
        </script>
    </body>
</html>